
utility = require('./utility');
exports = module.exports;

exports.prepareSimulation = function(req,res)
{
	CreateLandmass(req);
	CreateOcean(req, Math.floor(req.area * 2)); //  Each tile would get 25
    res(null);
};

function CreateLandmass(ctx)
{
    var continentMap = new Array(ctx.area);
    for(var z = 0 ; z < ctx.area; z++) { 
        continentMap[z]=0;
    }
    
    for (var c = 0; c < 3; c++)
    {
        //  Create continent height
        var centerContinentX = -1;
        var centerContinentY = -1;

        while (centerContinentX == -1 || centerContinentY == -1)
        {
            var attemptedX = (ctx.columns / 2) + utility.randomNumberBetween(-ctx.columns / 4, ctx.columns / 4);
            var attemptedY = (ctx.rows / 2) + utility.randomNumberBetween(-ctx.rows / 4, ctx.rows / 4);
                   
            if (continentMap[ctx.ConvertToZ({f:attemptedX, s: attemptedY})] == 0)
            {
                centerContinentX = attemptedX;
                centerContinentY = attemptedY;
            }
        }

        //How far we venture from the continent to place a blob
        var radius = ((ctx.columns + ctx.rows) / 2) / 6;

        for (var i = 0; i < 5; i++)
        {
            var blobCenter = {
                f:centerContinentX + utility.randomNumberBetween(-radius,radius),
                s:centerContinentY + utility.randomNumberBetween(-radius,radius)};
            
            ctx.WrapCoordinate(blobCenter);
            
            var blob_radius = utility.randomNumberBetween(2,8);
            
            var blobResults = ctx.GetRingOfCoordinates(ctx.ConvertToZ(blobCenter), blob_radius, true);

            for (var p = 0; p < blobResults.length; p++)
            {
                 if(continentMap[blobResults[p]]!=1)
                 {
                    ctx.height[blobResults[p]] += utility.randomNumberBetween(2,5);
                    continentMap[blobResults[p]] = 1;
                    
                }
            }
        }

    }

}
function CreateOcean(ctx,totalWaterRequired)
{
	var numberPillars = 100;
	for (var p = 0; p < numberPillars; p++)
    {
        CreatePillarOfWaterAtZ(ctx, 
            utility.randomNumberBetween(0, ctx.area), 
            totalWaterRequired / numberPillars);
    }
    ResolveWater(ctx);

}
function CreatePillarOfWaterAtZ(ctx, z, unitsOfWater)
{
	ctx.depth[z] += unitsOfWater;
	ctx.unresolvedWater[z] = true;
}

function ResolveWater(ctx)
{
	var isFlat = true;
    var accuracy = 0.005;
    do
    {
        isFlat = true; //  Reset test that ocean is flat

        //  Check each coordinate for weird things
        for (var z = 0; z < ctx.area; z++)
        {
            if (ctx.unresolvedWater[z] == false)
                continue;


            isFlat = false;
            var depth = ctx.depth[z];

            if (depth == 0)
            {
                //  There is no water to resolve
                ctx.unresolvedWater[z] = false;
                continue;
            }

            var height = ctx.height[z];
            var elevation = depth + height;

            var neighbors = ctx.GetNeighbors(z, false);

            var numberPossibleDonees = 0;
            do
            {
                depth = ctx.depth[z];
                elevation = depth + height;

                var steepestSlope = 0;
                var steepestSlopeValue = 0;
                numberPossibleDonees = 0;

                //  Find the steepest slope
                for (var n = 0; n < neighbors.length; n++)
                {
                    var n_index = neighbors[n];

                    var neighborDepth = ctx.depth[n_index];
                    var neighborHeight = ctx.height[n_index];
                    var neighborElevation = neighborDepth + neighborHeight;

                    var slope = elevation - neighborElevation;

                    //  Do we have a downward slow too great?
                    if (slope > accuracy)
                    {
                        numberPossibleDonees++;

                        if (slope > steepestSlopeValue)
                        {
                            steepestSlope = n;
                            steepestSlopeValue = slope;
                        }
                    }

                    //  Do we have an upward slope that is too great?
                    if (slope < -accuracy)
                    {
                        //  If that plot has water then it needs to queue up for it
                        if (neighborDepth > 0)
                        {
                            ctx.unresolvedWater[n_index] = true;
                        }
                    }
                }

                if (numberPossibleDonees >= 1)
                {
                    //  There was at least one downward slope that was too great

                    var n_index = neighbors[steepestSlope];
                    ctx.unresolvedWater[n_index] = true;

                    //  Can we pass half our height difference
                    if (ctx.depth[z] > (steepestSlopeValue / 2))
                    {
                        //  Yes we can
                        ctx.depth[z] -= (steepestSlopeValue / 2);
                        ctx.depth[n_index] += (steepestSlopeValue / 2);
                    }
                    else
                    {
                        //  No we cant give enoguht to level them so we give all instead
                        ctx.depth[z] = 0;
                        ctx.depth[n_index] += ctx.depth[z];
                    }


                }
                else
                {
                    //  There was nothing to put out so 
                    ctx.unresolvedWater[z] = false;
                }
            }
            //If we had more than one possibility than we can try again
            while (numberPossibleDonees > 1 && ctx.depth[z] > 0);
        }

    }
    while (isFlat == false);
}