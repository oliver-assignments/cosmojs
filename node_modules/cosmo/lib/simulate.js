
utility = require('./utility');
exports = module.exports;

exports.prepareSimulation = function(req,res)
{
	CreateLandmass(req);
    SetSunlight(req);
    EstimateRainfall(req);
	CreateOcean(req, req.area * 2); //  Each tile would get 25
    SprayPlants(req);
    res(null);
};
exports.simulateDay = function(req,res)
{
    //console.log("A day! " + req.day);
};
exports.onMonth = function(req,res)
{
    //console.log("A month! " + req.month);
};
exports.onYear = function(req,res)
{
    //console.log("A year! " + req.year);
};

function CreateLandmass(ctx)
{
    var continentMap = new Array(ctx.area);
    for(var z = 0 ; z < ctx.area; z++) { 
        continentMap[z]=0;
    }
    
    for (var c = 0; c < 3; c++)
    {
        //  Create continent height
        var centerContinentX = -1;
        var centerContinentY = -1;

        while (centerContinentX == -1 || centerContinentY == -1)
        {
            var attemptedX = (ctx.columns / 2) + utility.randomNumberBetween(-ctx.columns / 4, ctx.columns / 4);
            var attemptedY = (ctx.rows / 2) + utility.randomNumberBetween(-ctx.rows / 4, ctx.rows / 4);
                   
            if (continentMap[ctx.ConvertToZ({f:attemptedX, s: attemptedY})] == 0)
            {
                centerContinentX = attemptedX;
                centerContinentY = attemptedY;
            }
        }

        //How far we venture from the continent to place a blob
        var radius = ((ctx.columns + ctx.rows) / 2) / 6;

        for (var i = 0; i < 5; i++)
        {
            var blobCenter = {
                f:centerContinentX + utility.randomNumberBetween(-radius,radius),
                s:centerContinentY + utility.randomNumberBetween(-radius,radius)};
            
            ctx.WrapCoordinate(blobCenter);
            
            var blob_radius = utility.randomNumberBetween(2,8);
            
            var blobResults = ctx.GetRingOfCoordinates(ctx.ConvertToZ(blobCenter), blob_radius, true);

            for (var p = 0; p < blobResults.length; p++)
            {
                 if(continentMap[blobResults[p]]!=1)
                 {
                    ctx.height[blobResults[p]] += utility.randomNumberBetween(2,5);
                    continentMap[blobResults[p]] = 1;
                    
                }
            }
        }

    }

}
function CreateOcean(ctx,totalWaterRequired)
{
	var numberPillars = 100;
	for (var p = 0; p < numberPillars; p++)
    {
        CreatePillarOfWaterAtZ(ctx, 
            utility.randomNumberBetween(0, ctx.area), 
            totalWaterRequired / numberPillars);
    }
    ResolveWater(ctx);

}
function CreatePillarOfWaterAtZ(ctx, z, unitsOfWater)
{
	ctx.depth[z] += unitsOfWater;
	ctx.unresolvedWater[z] = true;
}

function ResolveWater(ctx)
{
	var isFlat = true;
    var accuracy = 0.05;//0.005;
    do
    {
        isFlat = true; //  Reset test that ocean is flat

        //  Check each coordinate for weird things
        for (var z = 0; z < ctx.area; z++)
        {
            if (ctx.unresolvedWater[z] == false)
                continue;


            isFlat = false;
            var depth = ctx.depth[z];

            if (depth == 0)
            {
                //  There is no water to resolve
                ctx.unresolvedWater[z] = false;
                continue;
            }

            var height = ctx.height[z];
            var elevation = depth + height;

            var neighbors = ctx.GetNeighbors(z, false);

            var numberPossibleDonees = 0;
            do
            {
                depth = ctx.depth[z];
                elevation = depth + height;

                var steepestSlope = 0;
                var steepestSlopeValue = 0;
                numberPossibleDonees = 0;

                //  Find the steepest slope
                for (var n = 0; n < neighbors.length; n++)
                {
                    var n_index = neighbors[n];

                    var neighborDepth = ctx.depth[n_index];
                    var neighborHeight = ctx.height[n_index];
                    var neighborElevation = neighborDepth + neighborHeight;

                    var slope = elevation - neighborElevation;

                    //  Do we have a downward slow too great?
                    if (slope > accuracy)
                    {
                        numberPossibleDonees++;

                        if (slope > steepestSlopeValue)
                        {
                            steepestSlope = n;
                            steepestSlopeValue = slope;
                        }
                    }

                    //  Do we have an upward slope that is too great?
                    if (slope < -accuracy)
                    {
                        //  If that plot has water then it needs to queue up for it
                        if (neighborDepth > 0)
                        {
                            ctx.unresolvedWater[n_index] = true;
                        }
                    }
                }

                if (numberPossibleDonees >= 1)
                {
                    //  There was at least one downward slope that was too great

                    var n_index = neighbors[steepestSlope];
                    ctx.unresolvedWater[n_index] = true;

                    //  Can we pass half our height difference
                    if (ctx.depth[z] > (steepestSlopeValue / 2))
                    {
                        //  Yes we can
                        ctx.depth[z] -= (steepestSlopeValue / 2);
                        ctx.depth[n_index] += (steepestSlopeValue / 2);
                    }
                    else
                    {
                        //  No we cant give enoguht to level them so we give all instead
                        ctx.depth[z] = 0;
                        ctx.depth[n_index] += ctx.depth[z];
                    }


                }
                else
                {
                    //  There was nothing to put out so 
                    ctx.unresolvedWater[z] = false;
                }
            }
            //If we had more than one possibility than we can try again
            while (numberPossibleDonees > 1 && ctx.depth[z] > 0);
        }

    }
    while (isFlat == false);
}

function SprayPlants(ctx)
{
    for (var p = 0; p < ctx.plantArea; p++)
    {
        var z = ctx.ConvertPToZ(p);

        if(ctx.depth[z] > 0)
        {
            p+= ctx.plantColumnsPer;
            continue;
        }

        if(Math.random()>0.8)
        {
            //console.log("Seeding at " + p + " within province "+ z);
            ctx.dna[p] = 'dnamixnow';
            ctx.nutroStore[p] = 3;
            ctx.nuciumStore[p] = 3;
            ctx.waterStore[p] = 3;
            ctx.hasPlant[p] = true;
        }

    }
}

function SetSunlight(ctx)
{
    var equator = Math.round(ctx.rows * ctx.tilt);

    var minSunlight = 1;
    var maxSunlight = 100;

    var distanceBeforeTundra = Math.round(ctx.rows / 1.6);

    var lightOnRow = 0;

    for (var y = 0; y < ctx.rows; ++y)
    {
        //  Determining sunlight value
        var distanceToEquator = Math.abs(equator - y);

        
        
        if (distanceToEquator > distanceBeforeTundra)
        {
            lightOnRow = minSunlight;
        }
        else if (distanceToEquator == 0)
        {
            lightOnRow = maxSunlight;
        }
        else
        {
            var lightRatio =1-( distanceToEquator / distanceBeforeTundra);
            lightOnRow = Math.round((maxSunlight-minSunlight) * lightRatio);
        }

        //  Setting sunlight value
        for (var x = 0; x < ctx.columns; ++x)
        {
            ctx.sunlight[ctx.ConvertToZ({f:x, s:y})] = lightOnRow;
        }
    }
}

function EstimateRainfall(ctx)
{
    // var temperature = new Array(ctx.area);
    // var moisture = new Array(ctx.area);

    // //var pendingTemperature = new Array(ctx.area);
    // //var pendingMoisture = new Array(ctx.area);

    // //  Creating the wind!
    // for (var m = 0; m < ctx.area; m++)
    // {
    //     temperature[m] = ctx.sunlight[m];
    //     moisture[m] = 5;

    //     //pendingMoisture[m] = 0;
    //     //pendingTemperature[m] = 0;
    // }

    //var rainLikelihood = new Array(ctx.area);
    //var windDirection = ctx.rotation;

    // for (var m = 0; m < ctx.area; m++)
    // {
    //     var coord = ctx.ConvertToCoord(m);
    //     rainLikelihood[m]=0;


        

    //     var previousCoord = ctx.ConvertToZ({f:coord.f+windDirection,s:coord.s});
    //     var upCoord = ctx.ConvertToZ({f:nextCoord.f,s:nextCoord.s-1});
    //     var downCoord = ctx.ConvertToZ({f:nextCoord.f,s:nextCoord.s+1});
        
    //     //  This province has water
    //     if(ctx.depth[m] > 0)
    //     {
    //         rainLikelihood[m]++;
    //     }
        
    //     if(ctx.depth[previousCoord] == 0)
    //     {
    //         rainLikelihood[m]--;
    //     }

    //     if( coord.y < Math.round(ctx.rows * ctx.tilt))
    //     {
    //         //Above equator
            
    //     }
    //     else if(coord.y > Math.round(ctx.rows * ctx.tilt))
    //     {
    //         //Below
            
    //     }
    //     else
    //     {
    //         //on
    //     }



    //     rainLikelihood[m] *= sunlight[m];

    // }

    // for (var q = 0; q < 1000; q++)
    // {
    //     //  Clear pending changes
    //     for (var m = 0; m < ctx.area; m++)
    //     {
    //         pendingMoisture[m] = 0;
    //         pendingTemperature[m] = 0;
    //     }

    //     //  Collecting temperature and moisture from environment
    //     for (var m = 0; m < ctx.area; m++)
    //     {
    //         //  Moisture
    //         if (ctx.depth[m] > 0.0)
    //         {
    //             //  % chance of gaining moisture from ocean 
    //             if (utility.randomNumberBetween(0, 100) > 60) moisture[m]++;
                
    //             //  Don't exceed a moisture of 10
    //             if (moisture[m] > 10) moisture[m] = 10;
    //         }
    //         else
    //         {
    //             //  And losing it to land
    //             moisture[m] -= 2;
    //             if (utility.randomNumberBetween(0, 100) > 60) moisture[m]--;
    //             if (moisture[m] < 0) moisture[m] = 0;
    //         }

    //         //  Temperature
    //         if (ctx.sunlight[m] > temperature[m])
    //         {
    //             //  Gaining temperature from sunlight
    //             temperature[m]++;
    //             moisture[m]++;
    //             if (temperature[m] > 10) temperature[m] = 10;
    //         }
    //         else
    //         {
    //             temperature[m] -= 2;
    //             if (temperature[m] < 0) temperature[m] = 0;
    //         }

    //         //  Artic regions killing moisture
    //         if (temperature[m] <= 1)
    //         {
    //             moisture[m] -= 3;
    //             if (moisture[m] < 0) moisture[m] = 0;
    //         }
    //         else if (temperature[m] <= 3)
    //         {
    //             moisture[m] -= 2;
    //             if (moisture[m] < 0) moisture[m] = 0;
    //         }

    //     }
    //     //  Moving wind!
    //     for (var m = 0; m < ctx.area; m++)
    //     {
    //         var coord = ctx.ConvertToCoord(m);

    //         var nextCoord = ctx.ConvertToZ({f:coord.f+windDirection,s:coord.s});
    //         var upCoord = ctx.ConvertToZ({f:nextCoord.f,s:nextCoord.s-1});
    //         var downCoord = ctx.ConvertToZ({f:nextCoord.f,s:nextCoord.s+1});
            
    //         if (temperature[m] > pendingTemperature[nextCoord]
    //             &&
    //             moisture[m] > pendingMoisture[nextCoord])
    //         {
    //             pendingTemperature[nextCoord] = temperature[m]++;
    //             pendingMoisture[nextCoord] = moisture[m]++;
    //         }
    //         if (temperature[m] > pendingTemperature[upCoord]
    //             &&
    //             moisture[m] > pendingMoisture[upCoord])
    //         {
    //             pendingTemperature[upCoord] = temperature[m]++;
    //             pendingMoisture[upCoord] = moisture[m]++;
    //         }
    //         if (temperature[m] > pendingTemperature[downCoord]
    //             &&
    //             moisture[m] > pendingMoisture[downCoord])
    //         {
    //             pendingTemperature[downCoord] = temperature[m]++;
    //             pendingMoisture[downCoord] = moisture[m]++;
    //         }
    //     }

    //     //  Applying pending changes to 
    //     for (var m = 0; m < ctx.area; m++)
    //     {
    //         temperature[m] = pendingTemperature[m];
    //         moisture[m] = pendingMoisture[m];
    //     }
    // }

    //  Applying the final moisture
    for (var m = 0; m < ctx.area; m++)
    {
        //console.log(moisture[m]);
        ctx.rainfall[m] = 100 * (Math.abs((ctx.rows/2) - ctx.ConvertToCoord(m).s)/(ctx.rows/2));
    }
}


