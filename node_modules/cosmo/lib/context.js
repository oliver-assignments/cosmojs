exports = module.exports;
var utility = require('./utility');

exports.createContext = function(name, columns, rows, myTilt, myRotationDirection) 
{
    var ctx = {};
    ctx.name = name;
    
    ctx.columns = columns;
    ctx.rows = rows;
    ctx.area = rows * columns;

    ctx.tilt = myTilt;
    ctx.rotationDirection = myRotationDirection;

    ctx.day = 1;
    ctx.month = 1;
    ctx.year = 1;

    ctx.highest = 1;
    ctx.hottest = 1;
    ctx.deepest = 1;
    ctx.brightest = 1;
    ctx.wettest = 1;
    ctx.tallest = 1;

    ctx.plantColumns = ctx.columns * 1;
    ctx.plantRows = ctx.rows * 1;
    ctx.plantArea = ctx.plantColumns * ctx.plantRows;

    ctx.tectonic = new Array(ctx.area);
    ctx.heat = new Array(ctx.area);
    ctx.height = new Array(ctx.area);
    ctx.depth = new Array(ctx.area);
    ctx.sunlight = new Array(ctx.area);
    ctx.rainfall = new Array(ctx.area);

    ctx.unresolvedWater = new Array(ctx.area);

    //  PLOT DATA  //
    ctx.soilNucium = new Array(ctx.plantArea);
    ctx.soilNutro = new Array(ctx.plantArea);

    //  Plant data
    ctx.deadPlant = new Array(ctx.plantArea);
    ctx.nuciumStore = new Array(ctx.plantArea);
    ctx.nutroStore = new Array(ctx.plantArea);
    ctx.waterStore = new Array(ctx.plantArea);

    for(var z = 0 ; z < ctx.area; z++)
    {   
        ctx.tectonic[z] = 0;//-1;
        ctx.heat[z] = 0;

        ctx.height[z] = 2;// + utility.randomNumberBetween(0,500);
        ctx.depth[z] = 0;

        ctx.sunlight[z] = 1;
        ctx.rainfall[z] = 5;

        ctx.unresolvedWater[z] = false;
    }

    //  Initializing plots
    for(var p = 0 ; p < ctx.plantArea; p++)
    {
        ctx.soilNutro[p] = 5;
        ctx.soilNucium[p] = 5;

        ctx.deadPlant[p] = true;
        ctx.nuciumStore[p] = 0;
        ctx.nutroStore[p] = 0;
        ctx.waterStore[p] = 0;
    }
    

    ctx.WrapCoordinate = function(coord)
    {
        while (coord.f < 0)
        {
            coord.f += ctx.columns;
        }
        while (coord.f >= ctx.numberColumns)
        {
            coord.f -= ctx.columns;
        }

        while (coord.s < 0)
        {
            coord.s += ctx.rows;
        }
        while (coord.s >= ctx.numberRows)
        {
            coord.s -= ctx.columns;
        }

        return coord;
    };

    ctx.ConvertToZ = function(coord)
    {
        ctx.WrapCoordinate(coord);
        return coord.f + ctx.columns * coord.s;
    };

    ctx.WrapZ = function(z) {

        while(z<0) {
            console.log(z + " + " + ctx.area);
            z += ctx.area;
        }
        while(z>=ctx.area) {
            console.log(z + " - " + ctx.area);
            z -= ctx.area;
        }
        return z;
     };
    ctx.ConvertToCoord = function(z)
    {
        ctx.WrapZ(z);
        return { f: Math.round(z % ctx.columns), s: Math.round(z / ctx.columns) };
    };

    ctx.GetNeighbors = function(z, includeDiagonals)
    {
        var neighbors = new Array();

        var center = ctx.ConvertToCoord(z);
        
        neighbors.push(ctx.ConvertToZ({f:center.f,s:center.s-1}));
        neighbors.push(ctx.ConvertToZ({f:center.f,s:center.s+1}));
        neighbors.push(ctx.ConvertToZ({f:center.f-1,s:center.s}));
        neighbors.push(ctx.ConvertToZ({f:center.f+1,s:center.s}));

        if (includeDiagonals)
        {
            neighbors.push(ctx.ConvertToZ({f:center.f-1,s:center.s-1}));
            neighbors.push(ctx.ConvertToZ({f:center.f+1,s:center.s-1}));
            neighbors.push(ctx.ConvertToZ({f:center.f-1,s:center.s+1}));
            neighbors.push(ctx.ConvertToZ({f:center.f+1,s:center.s+1})); 
        }

        return neighbors;
    };


    ctx.GetRingOfCoordinates = function(z, radius, doGetCenter)
    {
        
        var ring = new Array();
        
        var center = ctx.ConvertToCoord(z);

        //  Handle center
        if (doGetCenter)
        {
            ring.push(ctx.ConvertToZ(center));
        }
        //  Spokes
        for (var r = 1; r <= radius; r++)
        {
            ring.push(ctx.ConvertToZ({f:center.f,s:center.s-r}));
            ring.push(ctx.ConvertToZ({f:center.f,s:center.s+r}));
            ring.push(ctx.ConvertToZ({f:center.f-r,s:center.s}));
            ring.push(ctx.ConvertToZ({f:center.f+r,s:center.s}));
        }

        //  Pie slices
        for (var r = radius; r > 0; r--)
        {
            var x = center.f + 1;
            var y = center.s - r + 1;

            while (x > center.f)
            {
                if (y != center.s)
                {
                    //console.log({f:x, s:y});
                    ring.push(ctx.ConvertToZ({f:x, s:y}));
                }

                if (y < center.s)
                {
                    x++;
                }
                else
                {
                    x--;
                }

                y++;
            }
            x--;
            y--;
            while (x < center.f)
            {
                if (y != center.s)
                {
                    //console.log({f:x, s:y});
                    ring.push(ctx.ConvertToZ({f:x, s:y}));
                }

                if (y > center.s)
                {
                    x--;
                }
                else
                {
                    x++;
                }

                y--;
            }
        }
        return ring;
    
    };


    return ctx;
};
